# -*- coding: utf-8 -*-
"""Project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1McLbu4MjoJpGvZBZZNDYTiWkEutaPpZj
"""



# 1) Install
!pip -q install pymongo

# 2) Imports
from datetime import datetime, timedelta
from pymongo import MongoClient, ASCENDING, errors
from bson import ObjectId

"""# PART 1"""

"""
EduHub Validators & Indexes Setup
---------------------------------
Creates $jsonSchema validators and indexes for:
- users, courses, enrollments, lessons, assignments, submissions

Usage:
1) Local MongoDB:
   - Ensure MongoDB is running on mongodb://localhost:27017/
   - Run:  python eduhub_validators_setup.py

2) MongoDB Atlas:
   - Put your SRV string into MONGO_URI below (mongodb+srv://...)
   - Run:  python eduhub_validators_setup.py
"""
from pymongo import MongoClient, ASCENDING, errors
from datetime import datetime, timezone
from bson import ObjectId

# ---------- CONFIG ----------
MONGO_URI = "mongodb+srv://Abisola_lufadeju:Oluwafikayomibaby123.@cluster0.yy4xw2j.mongodb.net/"   # or your Atlas SRV
DB_NAME   = "eduhub_db"
# ----------------------------

def utcnow():
    return datetime.now(timezone.utc)

def create_or_update_collection(db, name, schema):
    try:
        db.create_collection(name, validator={"$jsonSchema": schema})
        print(f"Created collection: {name}")
    except errors.CollectionInvalid:
        db.command("collMod", name, validator={"$jsonSchema": schema})
        print(f"Updated validator for collection: {name}")

def main():
    client = MongoClient(MONGO_URI)
    db = client[DB_NAME]

    users_schema = {
        "bsonType": "object",
        "required": ["email", "firstName", "lastName", "role", "dateJoined"],
        "properties": {
            "userId": {"bsonType": "string"},
            "email": {"bsonType": "string", "pattern": r"^[^@\s]+@[^@\s]+\.[^@\s]+$"},
            "firstName": {"bsonType": "string", "minLength": 1},
            "lastName": {"bsonType": "string", "minLength": 1},
            "role": {"enum": ["student", "instructor"]},
            "dateJoined": {"bsonType": "date"},
            "profile": {
                "bsonType": "object",
                "properties": {
                    "bio": {"bsonType": "string"},
                    "avatar": {"bsonType": "string"},
                    "skills": {"bsonType": "array", "items": {"bsonType": "string"}}
                }
            },
            "isActive": {"bsonType": "bool"}
        },
        "additionalProperties": True
    }

    courses_schema = {
        "bsonType": "object",
        "required": ["title", "instructorObjectId", "createdAt"],
        "properties": {
            "courseId": {"bsonType": "string"},
            "title": {"bsonType": "string", "minLength": 1},
            "description": {"bsonType": "string"},
            "instructorObjectId": {"bsonType": "objectId"},
            "instructorId": {"bsonType": "string"},
            "category": {"bsonType": "string"},
            "level": {"enum": ["beginner", "intermediate", "advanced"]},
            "duration": {"bsonType": ["double", "int", "long"], "minimum": 0},
            "price": {"bsonType": ["double", "int", "long"], "minimum": 0},
            "tags": {"bsonType": "array", "items": {"bsonType": "string"}},
            "createdAt": {"bsonType": "date"},
            "updatedAt": {"bsonType": "date"},
            "isPublished": {"bsonType": "bool"},
            "lessonsCount": {"bsonType": ["int", "long"], "minimum": 0}
        },
        "additionalProperties": True
    }

    enrollments_schema = {
        "bsonType": "object",
        "required": ["studentObjectId", "courseObjectId", "enrolledAt", "status"],
        "properties": {
            "enrollmentId": {"bsonType": "string"},
            "studentObjectId": {"bsonType": "objectId"},
            "studentId": {"bsonType": "string"},
            "courseObjectId": {"bsonType": "objectId"},
            "courseId": {"bsonType": "string"},
            "enrolledAt": {"bsonType": "date"},
            "status": {"enum": ["active", "completed", "dropped"]},
            "progress": {
                "bsonType": "object",
                "properties": {
                    "percent": {"bsonType": ["double", "int", "long"], "minimum": 0, "maximum": 100},
                    "lastLessonObjectId": {"bsonType": "objectId"},
                    "lastUpdated": {"bsonType": "date"}
                }
            }
        },
        "additionalProperties": True
    }

    lessons_schema = {
        "bsonType": "object",
        "required": ["courseObjectId", "title", "order", "createdAt"],
        "properties": {
            "lessonId": {"bsonType": "string"},
            "courseObjectId": {"bsonType": "objectId"},
            "courseId": {"bsonType": "string"},
            "title": {"bsonType": "string", "minLength": 1},
            "content": {"bsonType": "string"},
            "order": {"bsonType": ["int", "long"], "minimum": 1},
            "durationMinutes": {"bsonType": ["int", "long"], "minimum": 0},
            "createdAt": {"bsonType": "date"},
            "updatedAt": {"bsonType": "date"}
        },
        "additionalProperties": True
    }

    assignments_schema = {
        "bsonType": "object",
        "required": ["courseObjectId", "title", "points", "createdAt"],
        "properties": {
            "assignmentId": {"bsonType": "string"},
            "courseObjectId": {"bsonType": "objectId"},
            "courseId": {"bsonType": "string"},
            "lessonObjectId": {"bsonType": ["objectId", "null"]},
            "lessonId": {"bsonType": "string"},
            "title": {"bsonType": "string", "minLength": 1},
            "description": {"bsonType": "string"},
            "dueAt": {"bsonType": "date"},
            "points": {"bsonType": ["int", "long"], "minimum": 0},
            "createdAt": {"bsonType": "date"},
            "updatedAt": {"bsonType": "date"}
        },
        "additionalProperties": True
    }

    submissions_schema = {
        "bsonType": "object",
        "required": ["assignmentObjectId", "studentObjectId", "submittedAt", "status"],
        "properties": {
            "submissionId": {"bsonType": "string"},
            "assignmentObjectId": {"bsonType": "objectId"},
            "assignmentId": {"bsonType": "string"},
            "studentObjectId": {"bsonType": "objectId"},
            "studentId": {"bsonType": "string"},
            "submittedAt": {"bsonType": "date"},
            "status": {"enum": ["submitted", "graded", "resubmitted", "late"]},
            "files": {"bsonType": "array", "items": {"bsonType": "string"}},
            "grade": {
                "bsonType": ["object", "null"],
                "properties": {
                    "score": {"bsonType": ["double", "int", "long"], "minimum": 0},
                    "maxPoints": {"bsonType": ["int", "long"], "minimum": 0},
                    "feedback": {"bsonType": "string"},
                    "gradedAt": {"bsonType": "date"},
                    "gradedByObjectId": {"bsonType": "objectId"},
                    "gradedById": {"bsonType": "string"}
                }
            }
        },
        "additionalProperties": True
    }

    # Create/Update collections
    create_or_update_collection(db, "users", users_schema)
    create_or_update_collection(db, "courses", courses_schema)
    create_or_update_collection(db, "enrollments", enrollments_schema)
    create_or_update_collection(db, "lessons", lessons_schema)
    create_or_update_collection(db, "assignments", assignments_schema)
    create_or_update_collection(db, "submissions", submissions_schema)

    # Indexes
    db.users.create_index([("email", ASCENDING)], unique=True, name="uniq_email")
    db.users.create_index([("userId", ASCENDING)], unique=True, name="uniq_userId")

    db.courses.create_index([("courseId", ASCENDING)], unique=True, name="uniq_courseId")
    db.courses.create_index([("instructorObjectId", ASCENDING)], name="by_instructor")
    db.courses.create_index([("tags", ASCENDING)], name="by_tags")

    db.enrollments.create_index([("studentObjectId", ASCENDING), ("courseObjectId", ASCENDING)], unique=True, name="uniq_student_course")
    db.enrollments.create_index([("status", ASCENDING)], name="by_status")

    db.lessons.create_index([("courseObjectId", ASCENDING), ("order", ASCENDING)], unique=True, name="uniq_course_order")

    db.assignments.create_index([("courseObjectId", ASCENDING), ("dueAt", ASCENDING)], name="by_course_due")

    db.submissions.create_index([("assignmentObjectId", ASCENDING), ("studentObjectId", ASCENDING)], unique=True, name="uniq_assignment_student")
    db.submissions.create_index([("status", ASCENDING)], name="by_submission_status")

    print("Validators and indexes created ✅")

if __name__ == "__main__":
    main()

"""#PART 1.2"""

"""
EduHub Validators & Indexes Setup
---------------------------------
Creates $jsonSchema validators and indexes for:
- users, courses, enrollments, lessons, assignments, submissions

Usage:
1) Local MongoDB:
   - Ensure MongoDB is running on mongodb://localhost:27017/
   - Run:  python eduhub_validators_setup.py

2) MongoDB Atlas:
   - Put your SRV string into MONGO_URI below (mongodb+srv://...)
   - Run:  python eduhub_validators_setup.py
"""

from pymongo import MongoClient, ASCENDING, errors
from datetime import datetime, timezone
from bson import ObjectId

# ---------- CONFIG ----------
MONGO_URI = "mongodb+srv://Abisola_lufadeju:Oluwafikayomibaby123.@cluster0.yy4xw2j.mongodb.net/"   # or your Atlas SRV
DB_NAME   = "eduhub_db"
# ----------------------------

def utcnow():
    return datetime.now(timezone.utc)

def create_or_update_collection(db, name, schema):
    try:
        db.create_collection(name, validator={"$jsonSchema": schema})
        print(f"Created collection: {name}")
    except errors.CollectionInvalid:
        db.command("collMod", name, validator={"$jsonSchema": schema})
        print(f"Updated validator for collection: {name}")

def main():
    client = MongoClient(MONGO_URI)
    db = client[DB_NAME]

    users_schema = {
        "bsonType": "object",
        "required": ["email", "firstName", "lastName", "role", "dateJoined"],
        "properties": {
            "userId": {"bsonType": "string"},
            "email": {"bsonType": "string", "pattern": r"^[^@\s]+@[^@\s]+\.[^@\s]+$"},
            "firstName": {"bsonType": "string", "minLength": 1},
            "lastName": {"bsonType": "string", "minLength": 1},
            "role": {"enum": ["student", "instructor"]},
            "dateJoined": {"bsonType": "date"},
            "profile": {
                "bsonType": "object",
                "properties": {
                    "bio": {"bsonType": "string"},
                    "avatar": {"bsonType": "string"},
                    "skills": {"bsonType": "array", "items": {"bsonType": "string"}}
                }
            },
            "isActive": {"bsonType": "bool"}
        },
        "additionalProperties": True
    }

    courses_schema = {
        "bsonType": "object",
        "required": ["title", "instructorObjectId", "createdAt"],
        "properties": {
            "courseId": {"bsonType": "string"},
            "title": {"bsonType": "string", "minLength": 1},
            "description": {"bsonType": "string"},
            "instructorObjectId": {"bsonType": "objectId"},
            "instructorId": {"bsonType": "string"},
            "category": {"bsonType": "string"},
            "level": {"enum": ["beginner", "intermediate", "advanced"]},
            "duration": {"bsonType": ["double", "int", "long"], "minimum": 0},
            "price": {"bsonType": ["double", "int", "long"], "minimum": 0},
            "tags": {"bsonType": "array", "items": {"bsonType": "string"}},
            "createdAt": {"bsonType": "date"},
            "updatedAt": {"bsonType": "date"},
            "isPublished": {"bsonType": "bool"},
            "lessonsCount": {"bsonType": ["int", "long"], "minimum": 0}
        },
        "additionalProperties": True
    }

    enrollments_schema = {
        "bsonType": "object",
        "required": ["studentObjectId", "courseObjectId", "enrolledAt", "status"],
        "properties": {
            "enrollmentId": {"bsonType": "string"},
            "studentObjectId": {"bsonType": "objectId"},
            "studentId": {"bsonType": "string"},
            "courseObjectId": {"bsonType": "objectId"},
            "courseId": {"bsonType": "string"},
            "enrolledAt": {"bsonType": "date"},
            "status": {"enum": ["active", "completed", "dropped"]},
            "progress": {
                "bsonType": "object",
                "properties": {
                    "percent": {"bsonType": ["double", "int", "long"], "minimum": 0, "maximum": 100},
                    "lastLessonObjectId": {"bsonType": ["objectId", "null"]},  # Fixed: Allow null for no progress
                    "lastUpdated": {"bsonType": "date"}
                }
            }
        },
        "additionalProperties": True
    }

    lessons_schema = {
        "bsonType": "object",
        "required": ["courseObjectId", "title", "order", "createdAt"],
        "properties": {
            "lessonId": {"bsonType": "string"},
            "courseObjectId": {"bsonType": "objectId"},
            "courseId": {"bsonType": "string"},
            "title": {"bsonType": "string", "minLength": 1},
            "content": {"bsonType": "string"},
            "order": {"bsonType": ["int", "long"], "minimum": 1},
            "durationMinutes": {"bsonType": ["int", "long"], "minimum": 0},
            "createdAt": {"bsonType": "date"},
            "updatedAt": {"bsonType": "date"}
        },
        "additionalProperties": True
    }

    assignments_schema = {
        "bsonType": "object",
        "required": ["courseObjectId", "title", "points", "createdAt"],
        "properties": {
            "assignmentId": {"bsonType": "string"},
            "courseObjectId": {"bsonType": "objectId"},
            "courseId": {"bsonType": "string"},
            "lessonObjectId": {"bsonType": ["objectId", "null"]},
            "lessonId": {"bsonType": ["string", "null"]},
            "title": {"bsonType": "string", "minLength": 1},
            "description": {"bsonType": "string"},
            "dueAt": {"bsonType": "date"},
            "points": {"bsonType": ["int", "long"], "minimum": 0},
            "createdAt": {"bsonType": "date"},
            "updatedAt": {"bsonType": "date"}
        },
        "additionalProperties": True
    }

    submissions_schema = {
        "bsonType": "object",
        "required": ["assignmentObjectId", "studentObjectId", "submittedAt", "status"],
        "properties": {
            "submissionId": {"bsonType": "string"},
            "assignmentObjectId": {"bsonType": "objectId"},
            "assignmentId": {"bsonType": "string"},
            "studentObjectId": {"bsonType": "objectId"},
            "studentId": {"bsonType": "string"},
            "submittedAt": {"bsonType": "date"},
            "status": {"enum": ["submitted", "graded", "resubmitted", "late"]},
            "files": {"bsonType": "array", "items": {"bsonType": "string"}},
            "grade": {
                "bsonType": ["object", "null"],
                "properties": {
                    "score": {"bsonType": ["double", "int", "long"], "minimum": 0},
                    "maxPoints": {"bsonType": ["int", "long"], "minimum": 0},
                    "feedback": {"bsonType": "string"},
                    "gradedAt": {"bsonType": "date"},
                    "gradedByObjectId": {"bsonType": "objectId"},
                    "gradedById": {"bsonType": "string"}
                }
            }
        },
        "additionalProperties": True
    }

    # Create/Update collections
    create_or_update_collection(db, "users", users_schema)
    create_or_update_collection(db, "courses", courses_schema)
    create_or_update_collection(db, "enrollments", enrollments_schema)
    create_or_update_collection(db, "lessons", lessons_schema)
    create_or_update_collection(db, "assignments", assignments_schema)
    create_or_update_collection(db, "submissions", submissions_schema)

    # Indexes
    db.users.create_index([("email", ASCENDING)], unique=True, name="uniq_email")
    db.users.create_index([("userId", ASCENDING)], unique=True, name="uniq_userId")

    db.courses.create_index([("courseId", ASCENDING)], unique=True, name="uniq_courseId")
    db.courses.create_index([("instructorObjectId", ASCENDING)], name="by_instructor")
    db.courses.create_index([("tags", ASCENDING)], name="by_tags")

    db.enrollments.create_index([("studentObjectId", ASCENDING), ("courseObjectId", ASCENDING)], unique=True, name="uniq_student_course")
    db.enrollments.create_index([("status", ASCENDING)], name="by_status")

    db.lessons.create_index([("courseObjectId", ASCENDING), ("order", ASCENDING)], unique=True, name="uniq_course_order")

    db.assignments.create_index([("courseObjectId", ASCENDING), ("dueAt", ASCENDING)], name="by_course_due")

    db.submissions.create_index([("assignmentObjectId", ASCENDING), ("studentObjectId", ASCENDING)], unique=True, name="uniq_assignment_student")
    db.submissions.create_index([("status", ASCENDING)], name="by_submission_status")

    print("Validators and indexes created ✅")

if __name__ == "__main__":
    main()

"""# PART 2"""

"""
EduHub Seeder (Task 2)
----------------------
Seeds sample data with correct relationships for EduHub:

- 20 users (mix of students/instructors)
- 8 courses across categories
- 25 lessons (attached to courses)
- 15 enrollments (student <-> course unique)
- 10 assignments (attached to courses and lessons)
- 12 submissions (student <-> assignment unique)

USAGE
-----
1) Install deps:  pip install pymongo faker
2) Edit MONGO_URI if using Atlas; keep localhost for local dev.
3) Run:  python eduhub_seed.py

This script works with the validators/indexes from `eduhub_validators_setup.py`.
If you used a different schema, adjust field names accordingly.
"""

import random
from datetime import datetime, timedelta, timezone
from pymongo import MongoClient, ASCENDING, errors
from bson import ObjectId
from collections import defaultdict

try:
    from faker import Faker
    faker = Faker()
except Exception:
    faker = None

# ---------- CONFIG ----------
MONGO_URI = "mongodb+srv://Abisola_lufadeju:Oluwafikayomibaby123.@cluster0.yy4xw2j.mongodb.net/"  # or your Atlas SRV
DB_NAME   = "eduhub_db"
SEED_COUNTS = {
    "users": 20,
    "courses": 8,
    "lessons": 25,
    "enrollments": 15,
    "assignments": 10,
    "submissions": 12,
}
CATEGORIES = ["databases", "programming", "math", "design", "security", "cloud", "ai", "analytics"]
LEVELS     = ["beginner", "intermediate", "advanced"]
# ----------------------------

def utcnow():
    return datetime.now(timezone.utc)

def fake_name():
    if faker:
        return faker.first_name(), faker.last_name()
    first = random.choice(["Ife","Sam","Grace","Ada","Ben","Tolu","Amara","Yusuf","Lana","Mo","Jade","Ayo","Chidi","Sade","Dami"])
    last  = random.choice(["Aluko","Adeyemi","Okoro","Hopper","Lovelace","Adebayo","Ahmed","Patel","Singh","Chen","Brown","Jones"])
    return first, last

def fake_email(first, last, idx):
    base = f"{first}.{last}".lower()
    return f"{base}{idx}@eduhub.local"

def main():
    client = MongoClient(MONGO_URI)
    db = client[DB_NAME]

    # Ensure indexes exist (idempotent)
    try:
        db.users.create_index([("email", ASCENDING)], unique=True, name="uniq_email")
        db.users.create_index([("userId", ASCENDING)], unique=True, name="uniq_userId")
        db.courses.create_index([("courseId", ASCENDING)], unique=True, name="uniq_courseId")
        db.enrollments.create_index([("studentObjectId", ASCENDING), ("courseObjectId", ASCENDING)], unique=True, name="uniq_student_course")
        db.lessons.create_index([("courseObjectId", ASCENDING), ("order", ASCENDING)], unique=True, name="uniq_course_order")
        db.submissions.create_index([("assignmentObjectId", ASCENDING), ("studentObjectId", ASCENDING)], unique=True, name="uniq_assignment_student")
    except Exception as e:
        print("Index creation note:", e)

    # Users
    users = []
    instructor_slots = set(random.sample(range(SEED_COUNTS["users"]), k=5))  # at least 5 instructors
    for i in range(SEED_COUNTS["users"]):
        first, last = fake_name()
        role = "instructor" if i in instructor_slots else "student"
        doc = {
            "userId": f"U-{1000+i}",
            "email": fake_email(first, last, i),
            "firstName": first,
            "lastName": last,
            "role": role,
            "dateJoined": utcnow() - timedelta(days=random.randint(1, 900)),
            "profile": {
                "bio": f"{first} {last} loves learning and teaching.",
                "skills": random.sample(["python","mongodb","sql","excel","powerbi","linux","git","math","design","security","aws","azure"], k=random.randint(1,4))
            },
            "isActive": True
        }
        try:
            res = db.users.insert_one(doc)
            doc["_id"] = res.inserted_id
            users.append(doc)
        except errors.DuplicateKeyError:
            doc["email"] = fake_email(first, last, i+9999)
            res = db.users.insert_one(doc)
            doc["_id"] = res.inserted_id
            users.append(doc)

    instructors = [u for u in users if u["role"] == "instructor"]
    students    = [u for u in users if u["role"] == "student"]
    if len(instructors) < 2:
        for u in users[:2]:
            db.users.update_one({"_id": u["_id"]}, {"$set": {"role":"instructor"}})
        instructors = [db.users.find_one({"_id": u["_id"]}) for u in users[:2]]
        students    = [u for u in users if u["_id"] not in {x["_id"] for x in instructors}]

    # Courses
    courses = []
    for i in range(SEED_COUNTS["courses"]):
        teacher = random.choice(instructors)
        created = utcnow() - timedelta(days=random.randint(1, 400))
        doc = {
            "courseId": f"C-{2000+i}",
            "title": f"{random.choice(['Intro','Advanced','Practical','Essentials of'])} {random.choice(['MongoDB','Python','SQL','Data Modeling','Cloud','Security','Design','Math'])}",
            "description": "Auto-generated sample course for EduHub.",
            "instructorObjectId": teacher["_id"],
            "instructorId": teacher["userId"],
            "category": random.choice(CATEGORIES),
            "level": random.choice(LEVELS),
            "duration": round(random.uniform(1.0, 12.0), 1),
            "price": round(random.uniform(0, 199), 2),
            "tags": random.sample(["mongodb","nosql","python","sql","etl","ai","ml","viz","cloud","devops","security","design"], k=random.randint(1,4)),
            "createdAt": created,
            "updatedAt": created,
            "isPublished": random.choice([True, False]),
            "lessonsCount": 0
        }
        res = db.courses.insert_one(doc)
        doc["_id"] = res.inserted_id
        courses.append(doc)

    # Lessons
    lessons = []
    orders_per_course = defaultdict(int)
    for i in range(SEED_COUNTS["lessons"]):
        course = random.choice(courses)
        next_order = orders_per_course[course["_id"]] + 1
        orders_per_course[course["_id"]] = next_order
        doc = {
            "lessonId": f"L-{3000+i}",
            "courseObjectId": course["_id"],
            "courseId": course["courseId"],
            "title": f"Lesson {next_order}: {random.choice(['Basics','Deep Dive','Practice','Recap','Project'])}",
            "content": "Short placeholder content for the lesson.",
            "order": next_order,
            "durationMinutes": random.randint(8, 30),
            "createdAt": utcnow() - timedelta(days=random.randint(1, 300)),
            "updatedAt": utcnow()
        }
        res = db.lessons.insert_one(doc)
        doc["_id"] = res.inserted_id
        lessons.append(doc)
        db.courses.update_one({"_id": course["_id"]}, {"$inc": {"lessonsCount": 1}})

    # Enrollments
    enrollments = []
    pairs_used = set()
    for i in range(SEED_COUNTS["enrollments"]):
        s = random.choice(students)
        c = random.choice(courses)
        key = (s["_id"], c["_id"])
        if key in pairs_used:
            continue
        pairs_used.add(key)
        percent = random.choice([0, 10, 25, 40, 50, 75, 90, 100])
        course_lessons = [l for l in lessons if l["courseObjectId"] == c["_id"]]
        last_lesson = random.choice(course_lessons)["_id"] if course_lessons and percent > 0 else None
        doc = {
            "enrollmentId": f"E-{4000+i}",
            "studentObjectId": s["_id"],
            "studentId": s["userId"],
            "courseObjectId": c["_id"],
            "courseId": c["courseId"],
            "enrolledAt": utcnow() - timedelta(days=random.randint(1, 150)),
            "status": "completed" if percent == 100 else "active",
            "progress": {
                "percent": percent,
                "lastLessonObjectId": last_lesson,
                "lastUpdated": utcnow()
            }
        }
        res = db.enrollments.insert_one(doc)
        doc["_id"] = res.inserted_id
        enrollments.append(doc)

    # Assignments
    assignments = []
    for i in range(SEED_COUNTS["assignments"]):
        course = random.choice(courses)
        course_lessons = [l for l in lessons if l["courseObjectId"] == course["_id"]]
        lesson_id = random.choice(course_lessons)["_id"] if course_lessons and random.random() < 0.8 else None
        lesson_id_str = None
        if lesson_id:
            lesson_doc = db.lessons.find_one({"_id": lesson_id})
            lesson_id_str = lesson_doc["lessonId"] if lesson_doc else None
        created = utcnow() - timedelta(days=random.randint(1, 60))
        doc = {
            "assignmentId": f"A-{5000+i}",
            "courseObjectId": course["_id"],
            "courseId": course["courseId"],
            "lessonObjectId": lesson_id,
            "lessonId": lesson_id_str,
            "title": f"Assignment {i+1}: {random.choice(['Quiz','Mini Project','Worksheet','Lab'])}",
            "description": "Auto-generated assignment.",
            "dueAt": created + timedelta(days=random.randint(3, 20)),
            "points": random.choice([10, 20, 50, 100]),
            "createdAt": created,
            "updatedAt": created
        }
        res = db.assignments.insert_one(doc)
        doc["_id"] = res.inserted_id
        assignments.append(doc)

    # Submissions
    submissions = []
    submitted_pairs = set()
    attempts = 0
    while len(submissions) < SEED_COUNTS["submissions"] and attempts < 100:  # Prevent infinite loop
        attempts += 1
        asg = random.choice(assignments)
        course_oid = asg["courseObjectId"]
        # Get students enrolled in this course
        enrolled_in_course = list(db.enrollments.find({"courseObjectId": course_oid}, {"studentObjectId": 1}))
        if not enrolled_in_course:
            continue
        student_doc = random.choice(enrolled_in_course)
        student_oid = student_doc["studentObjectId"]
        key = (asg["_id"], student_oid)
        if key in submitted_pairs:
            continue
        submitted_pairs.add(key)
        student_user = db.users.find_one({"_id": student_oid})
        submit_time = utcnow() - timedelta(days=random.randint(0, 10))
        is_late = submit_time > asg["dueAt"]
        base_status = random.choice(["submitted", "resubmitted"])
        status = "late" if is_late else base_status
        if random.random() < 0.5:  # 50% chance to be graded
            status = "graded"
        grade_obj = None
        if status == "graded":
            score = random.randint(0, asg["points"])
            teacher = random.choice([u for u in users if u["role"] == "instructor"])
            grade_obj = {
                "score": score,
                "maxPoints": asg["points"],
                "feedback": "Auto feedback",
                "gradedAt": submit_time + timedelta(hours=random.randint(1, 24)),
                "gradedByObjectId": teacher["_id"],
                "gradedById": teacher["userId"]
            }
        doc = {
            "submissionId": f"S-{6000+len(submissions)}",
            "assignmentObjectId": asg["_id"],
            "assignmentId": asg["assignmentId"],
            "studentObjectId": student_oid,
            "studentId": student_user["userId"],
            "submittedAt": submit_time,
            "status": status,
            "files": [f"https://files.eduhub.local/submissions/{len(submissions)}.pdf"],
            "grade": grade_obj
        }
        res = db.submissions.insert_one(doc)
        doc["_id"] = res.inserted_id
        submissions.append(doc)

    print("Seed complete ✅")
    print("Counts now:")
    for name in ["users","courses","lessons","enrollments","assignments","submissions"]:
        print(f"{name}: {db[name].count_documents({})}")

if __name__ == "__main__":
    main()

"""# PART 2.2"""

from pymongo import MongoClient
from bson import ObjectId

# Connect (use your URI)
client = MongoClient("mongodb+srv://Abisola_lufadeju:Oluwafikayomibaby123.@cluster0.yy4xw2j.mongodb.net/")
db = client["eduhub_db"]

# Sample Queries
print("=== Sample Users (First 3 Students) ===")
for user in db.users.find({"role": "student"}).limit(3):
    print(f"- {user['firstName']} {user['lastName']} (ID: {user['userId']})")

print("\n=== Published Courses ===")
for course in db.courses.find({"isPublished": True}).sort("title", 1):
    print(f"- {course['title']} by {course['instructorId']} (Category: {course['category']})")

print("\n=== Active Enrollments with Progress > 50% ===")
for enroll in db.enrollments.find({"status": "active", "progress.percent": {"$gt": 50}}).limit(3):
    print(f"- Student {enroll['studentId']} in {enroll['courseId']}: {enroll['progress']['percent']}% complete")

print("\n=== Recent Submissions ===")
for sub in db.submissions.find().sort("submittedAt", -1).limit(3):
    status = sub.get("status", "N/A")
    # Fixed: Safely handle null grade
    grade_obj = sub.get("grade")
    if grade_obj is None:
        grade = "Ungraded"
    else:
        grade = grade_obj.get("score", "Ungraded")
    print(f"- {sub['studentId']} submitted {sub['assignmentId']} ({status}, Grade: {grade})")

client.close()

"""# PART 3.1"""

"""
EduHub CRUD Operations - Task 3.1: Create Operations
--------------------------------------------------
This script demonstrates basic CREATE operations using PyMongo:

1. Add a new student user to the 'users' collection
2. Create a new course in the 'courses' collection (using an existing instructor)
3. Enroll the new student in the new course (adds to 'enrollments')
4. Add a new lesson to an existing course (e.g., the one just created)

Prerequisites:
- Run this in Google Colab or a Python environment with pymongo installed.
- Database: eduhub_db (from previous setup/seeder)
- Ensure validators/indexes are set up.

Run: !pip install pymongo  (if needed)
"""

from pymongo import MongoClient
from datetime import datetime, timedelta, timezone
from bson import ObjectId
import random

# ---------- CONFIG ----------
MONGO_URI = "mongodb+srv://Abisola_lufadeju:Oluwafikayomibaby123.@cluster0.yy4xw2j.mongodb.net/"
DB_NAME = "eduhub_db"
# ----------------------------

def utcnow():
    return datetime.now(timezone.utc)

def connect_db():
    client = MongoClient(MONGO_URI)
    return client[DB_NAME]

def task_3_1_create_student(db):
    """
    Task 3.1.1: Add a new student user
    - Generates unique email/userId
    - Inserts into 'users' with role='student'
    """
    # Fetch highest userId to generate next (e.g., U-1021)
    max_user = db.users.find_one(sort=[("userId", -1)])
    next_id = int(max_user["userId"].split("-")[1]) + 1 if max_user else 1000
    new_user_id = f"U-{next_id}"

    # Simple fake data (extend with faker if installed)
    first_name = random.choice(["Zara", "Kai", "Nova", "Rio"])
    last_name = random.choice(["Silva", "Lee", "Kim", "Patel"])
    email = f"{first_name.lower()}.{last_name.lower()}{next_id}@eduhub.local"

    new_student = {
        "userId": new_user_id,
        "email": email,
        "firstName": first_name,
        "lastName": last_name,
        "role": "student",
        "dateJoined": utcnow(),
        "profile": {
            "bio": f"{first_name} {last_name} is eager to learn new skills.",
            "skills": random.sample(["python", "sql", "data analysis"], k=2)
        },
        "isActive": True
    }

    try:
        result = db.users.insert_one(new_student)
        new_student["_id"] = result.inserted_id
        print(f"New student created: {new_student['firstName']} {new_student['lastName']} (ID: {new_user_id}, _id: {result.inserted_id})")
        return new_student
    except Exception as e:
        print(f"Error creating student: {e}")
        return None

def task_3_1_create_course(db):
    """
    Task 3.1.2: Create a new course
    - Uses an existing instructor (fetches first one)
    - Inserts into 'courses'
    """
    # Fetch an existing instructor
    instructor = db.users.find_one({"role": "instructor"})
    if not instructor:
        print("No instructor found—seed data first!")
        return None

    # Generate unique courseId (e.g., C-2009)
    max_course = db.courses.find_one(sort=[("courseId", -1)])
    next_course_id = int(max_course["courseId"].split("-")[1]) + 1 if max_course else 2000
    new_course_id = f"C-{next_course_id}"

    new_course = {
        "courseId": new_course_id,
        "title": "Advanced Data Visualization with Python",
        "description": "Master creating interactive dashboards and charts for data storytelling.",
        "instructorObjectId": instructor["_id"],
        "instructorId": instructor["userId"],
        "category": "analytics",
        "level": "intermediate",
        "duration": 8.5,  # hours
        "price": 49.99,
        "tags": ["python", "matplotlib", "seaborn", "dashboards"],
        "createdAt": utcnow(),
        "updatedAt": utcnow(),
        "isPublished": True,
        "lessonsCount": 0
    }

    try:
        result = db.courses.insert_one(new_course)
        new_course["_id"] = result.inserted_id
        print(f"New course created: {new_course['title']} (ID: {new_course_id}, _id: {result.inserted_id})")
        return new_course
    except Exception as e:
        print(f"Error creating course: {e}")
        return None

def task_3_1_enroll_student(db, student, course):
    """
    Task 3.1.3: Enroll a student in a course
    - Uses student and course ObjectIds
    - Inserts into 'enrollments' with initial progress 0%
    - Enforces unique student-course pair via index
    """
    if not student or not course:
        print("Student or course not provided!")
        return None

    # Check if already enrolled
    existing = db.enrollments.find_one({
        "studentObjectId": student["_id"],
        "courseObjectId": course["_id"]
    })
    if existing:
        print(f"Student {student['userId']} already enrolled in {course['courseId']}")
        return existing

    new_enrollment = {
        "enrollmentId": f"E-{random.randint(5000, 5999)}",  # Simple unique
        "studentObjectId": student["_id"],
        "studentId": student["userId"],
        "courseObjectId": course["_id"],
        "courseId": course["courseId"],
        "enrolledAt": utcnow(),
        "status": "active",
        "progress": {
            "percent": 0,
            "lastLessonObjectId": None,
            "lastUpdated": utcnow()
        }
    }

    try:
        result = db.enrollments.insert_one(new_enrollment)
        new_enrollment["_id"] = result.inserted_id
        print(f"Enrollment created: {student['userId']} in {course['courseId']} (ID: {new_enrollment['enrollmentId']}, _id: {result.inserted_id})")
        return new_enrollment
    except Exception as e:
        print(f"Error enrolling student: {e}")
        return None

def task_3_1_add_lesson(db, course):
    """
    Task 3.1.4: Add a new lesson to an existing course
    - Fetches next order (max +1)
    - Inserts into 'lessons'
    - Updates course lessonsCount
    """
    if not course:
        print(" Course not provided!")
        return None

    # Get next order
    max_lesson = db.lessons.find_one({"courseObjectId": course["_id"]}, sort=[("order", -1)])
    next_order = max_lesson["order"] + 1 if max_lesson else 1

    # Generate unique lessonId (e.g., L-3026)
    max_lesson_global = db.lessons.find_one(sort=[("lessonId", -1)])
    next_lesson_id_num = int(max_lesson_global["lessonId"].split("-")[1]) + 1 if max_lesson_global else 3000
    new_lesson_id = f"L-{next_lesson_id_num}"

    new_lesson = {
        "lessonId": new_lesson_id,
        "courseObjectId": course["_id"],
        "courseId": course["courseId"],
        "title": f"Lesson {next_order}: Building Interactive Charts",
        "content": "In this lesson, we'll explore Plotly for dynamic visualizations.",
        "order": next_order,
        "durationMinutes": random.randint(15, 45),
        "createdAt": utcnow(),
        "updatedAt": utcnow()
    }

    try:
        result = db.lessons.insert_one(new_lesson)
        new_lesson["_id"] = result.inserted_id

        # Update course lessonsCount
        db.courses.update_one({"_id": course["_id"]}, {"$inc": {"lessonsCount": 1}})

        print(f" New lesson added to {course['courseId']}: {new_lesson['title']} (Order: {next_order}, _id: {result.inserted_id})")
        print(f" Course {course['courseId']} now has {course.get('lessonsCount', 0) + 1} lessons.")
        return new_lesson
    except Exception as e:
        print(f" Error adding lesson: {e}")
        return None

def main():
    db = connect_db()

    print("=== Task 3.1: Create Operations Demo ===\n")

    # 1. Create new student
    new_student = task_3_1_create_student(db)

    # 2. Create new course
    new_course = task_3_1_create_course(db)

    if new_student and new_course:
        # 3. Enroll student in the new course
        enrollment = task_3_1_enroll_student(db, new_student, new_course)

        # 4. Add lesson to the new course
        lesson = task_3_1_add_lesson(db, new_course)

    print("\n=== Demo Complete! Check your database for new docs. ===")
    db.client.close()

if __name__ == "__main__":
    main()

"""# PART 3.2"""

"""
EduHub CRUD Operations - Task 3.2: Read Operations
-------------------------------------------------
This script demonstrates specific READ operations using PyMongo:

1. Find all active students (role='student' and isActive=True)
2. Retrieve course details with instructor information ($lookup join)
3. Get all courses in a specific category (e.g., 'analytics')
4. Find students enrolled in a particular course (join enrollments with users)
5. Search courses by title (case-insensitive, partial match using regex)

Prerequisites:
- Run in Google Colab or Python env with pymongo.
- Database: eduhub_db (with seeded + created data from previous tasks)

Examples use data like category='analytics', course='C-2008', search='Python'.
"""

from pymongo import MongoClient, DESCENDING
from datetime import datetime, timezone
from bson import ObjectId
import re

# ---------- CONFIG ----------
MONGO_URI = "mongodb+srv://Abisola_lufadeju:Oluwafikayomibaby123.@cluster0.yy4xw2j.mongodb.net/"
DB_NAME = "eduhub_db"
# ----------------------------

def connect_db():
    client = MongoClient(MONGO_URI)
    return client[DB_NAME]

def task_3_2_find_active_students(db):
    """
    Task 3.2.1: Find all active students
    - Queries users where role='student' and isActive=True
    - Sorts by dateJoined descending (newest first)
    """
    active_students = list(db.users.find({"role": "student", "isActive": True}).sort("dateJoined", DESCENDING))
    if active_students:
        print(f"Active students found: {len(active_students)} total")
        for student in active_students[:5]:  # Limit to 5 for demo
            print(f"   - {student['firstName']} {student['lastName']} (ID: {student['userId']}, Joined: {student['dateJoined']})")
        if len(active_students) > 5:
            print(f"   ... and {len(active_students) - 5} more")
        return active_students
    else:
        print("No active students found")
        return []

def task_3_2_course_details_with_instructor(db):
    """
    Task 3.2.2: Retrieve course details with instructor information
    - Uses $lookup to join courses with users on instructorObjectId
    - Projects key fields, sorts by title
    """
    pipeline = [
        {"$lookup": {
            "from": "users",
            "localField": "instructorObjectId",
            "foreignField": "_id",
            "as": "instructor"
        }},
        {"$unwind": "$instructor"},
        {"$project": {
            "courseId": 1,
            "title": 1,
            "description": 1,
            "category": 1,
            "level": 1,
            "price": 1,
            "instructorName": {"$concat": ["$instructor.firstName", " ", "$instructor.lastName"]},
            "instructorEmail": "$instructor.email"
        }},
        {"$sort": {"title": 1}}
    ]
    courses_with_instructors = list(db.courses.aggregate(pipeline))
    if courses_with_instructors:
        print(f"Courses with instructor details: {len(courses_with_instructors)} total")
        for course in courses_with_instructors[:3]:  # Limit to 3
            print(f"   - {course['title']} (Category: {course['category']}, Price: ${course['price']})")
            print(f"     By: {course['instructorName']} ({course['instructorEmail']})")
        if len(courses_with_instructors) > 3:
            print(f"   ... and {len(courses_with_instructors) - 3} more")
        return courses_with_instructors
    else:
        print("No courses found")
        return []

def task_3_2_courses_by_category(db, category):
    """
    Task 3.2.3: Get all courses in a specific category
    - Simple find query, sorts by level then title
    """
    courses = list(db.courses.find({"category": category}).sort([("level", 1), ("title", 1)]))
    if courses:
        print(f"Courses in category '{category}': {len(courses)} found")
        for course in courses:
            print(f"   - {course['title']} (Level: {course['level']}, Duration: {course['duration']} hrs)")
        return courses
    else:
        print(f"No courses in category: {category}")
        return []

def task_3_2_students_in_course(db, course_id):
    """
    Task 3.2.4: Find students enrolled in a particular course
    - Matches enrollments by courseId, joins with users
    - Filters active enrollments, projects student details
    """
    # First, get course ObjectId
    course = db.courses.find_one({"courseId": course_id})
    if not course:
        print(f"Course not found: {course_id}")
        return []

    pipeline = [
        {"$match": {"courseObjectId": course["_id"], "status": "active"}},
        {"$lookup": {
            "from": "users",
            "localField": "studentObjectId",
            "foreignField": "_id",
            "as": "student"
        }},
        {"$unwind": "$student"},
        {"$project": {
            "studentId": "$student.userId",
            "studentName": {"$concat": ["$student.firstName", " ", "$student.lastName"]},
            "studentEmail": "$student.email",
            "progress": "$progress.percent",
            "enrolledAt": 1
        }},
        {"$sort": {"enrolledAt": 1}}
    ]
    enrolled_students = list(db.enrollments.aggregate(pipeline))
    if enrolled_students:
        print(f"Students enrolled in {course_id} ('{course['title']}'): {len(enrolled_students)} active")
        for student in enrolled_students:
            print(f"   - {student['studentName']} (ID: {student['studentId']}, Progress: {student['progress']}%, Enrolled: {student['enrolledAt']})")
        return enrolled_students
    else:
        print(f"No active students enrolled in: {course_id}")
        return []

def task_3_2_search_courses_by_title(db, title_search):
    """
    Task 3.2.5: Search courses by title (case-insensitive, partial match)
    - Uses regex with $options: 'i' for case-insensitive
    - Sorts by relevance (score) then title
    """
    regex_pattern = re.compile(title_search, re.IGNORECASE)
    courses = list(db.courses.find({"title": {"$regex": regex_pattern}}).sort("title", 1))
    if courses:
        print(f"Courses matching title '{title_search}' (case-insensitive): {len(courses)} found")
        for course in courses:
            print(f"   - {course['title']} (Category: {course['category']}, Level: {course['level']})")
        return courses
    else:
        print(f"No courses matching title: {title_search}")
        return []

def main():
    db = connect_db()

    print("=== Task 3.2: Read Operations Demo ===\n")

    # Examples (adjust based on your data)
    category_example = "analytics"
    course_id_example = "C-2008"  # From Task 3.1
    title_search_example = "Python"

    # 1. Find active students
    task_3_2_find_active_students(db)

    print()  # Spacer

    # 2. Course details with instructor
    task_3_2_course_details_with_instructor(db)

    print()  # Spacer

    # 3. Courses by category
    task_3_2_courses_by_category(db, category_example)

    print()  # Spacer

    # 4. Students in a course
    task_3_2_students_in_course(db, course_id_example)

    print()  # Spacer

    # 5. Search courses by title
    task_3_2_search_courses_by_title(db, title_search_example)

    print("\n=== Demo Complete! All queries leverage indexes where possible. ===")
    db.client.close()

if __name__ == "__main__":
    main()

"""# PART 3.3"""

"""
EduHub CRUD Operations - Task 3.3: Update Operations
--------------------------------------------------
This script demonstrates specific UPDATE operations using PyMongo:

1. Update a user's profile information (e.g., update bio and avatar in profile)
2. Mark a course as published (set isPublished=True and update updatedAt)
3. Update assignment grades (update a submission's grade object and status)
4. Add tags to an existing course (append to tags array with $push)

Prerequisites:
- Run in Google Colab or Python env with pymongo.
- Database: eduhub_db (with data from previous tasks)

Examples use data like user U-1020, course C-2008, a submission.
"""

from pymongo import MongoClient
from datetime import datetime, timezone
from bson import ObjectId
import random

# ---------- CONFIG ----------
MONGO_URI = "mongodb+srv://Abisola_lufadeju:Oluwafikayomibaby123.@cluster0.yy4xw2j.mongodb.net/"
DB_NAME = "eduhub_db"
# ----------------------------

def utcnow():
    return datetime.now(timezone.utc)

def connect_db():
    client = MongoClient(MONGO_URI)
    return client[DB_NAME]

def task_3_3_update_user_profile(db, user_id):
    """
    Task 3.3.1: Update a user's profile information
    - Updates profile.bio and adds profile.avatar
    - Uses $set for nested fields
    """
    # Find user
    user = db.users.find_one({"userId": user_id})
    if not user:
        print(f"User not found: {user_id}")
        return None

    updated_bio = user["profile"]["bio"] + " Now focusing on data science career."
    new_avatar = f"https://avatars.eduhub.local/{user_id.lower()}.jpg"

    result = db.users.update_one(
        {"userId": user_id},
        {
            "$set": {
                "profile.bio": updated_bio,
                "profile.avatar": new_avatar
            }
        }
    )

    if result.modified_count > 0:
        print(f"User profile updated for {user_id}: New bio snippet - {updated_bio[:50]}...")
        print(f"   Added avatar: {new_avatar}")
        return True
    else:
        print(f"No update for user: {user_id}")
        return False

def task_3_3_mark_course_published(db, course_id):
    """
    Task 3.3.2: Mark a course as published
    - Sets isPublished=True and updates updatedAt
    """
    # Find course
    course = db.courses.find_one({"courseId": course_id})
    if not course:
        print(f"Course not found: {course_id}")
        return None

    now = utcnow()

    result = db.courses.update_one(
        {"courseId": course_id},
        {
            "$set": {
                "isPublished": True,
                "updatedAt": now
            }
        }
    )

    if result.modified_count > 0:
        print(f"Course {course_id} marked as published (was {course['isPublished']})")
        print(f"   Last updated: {now}")
        return True
    else:
        print(f"No update for course: {course_id}")
        return False

def task_3_3_update_assignment_grades(db, submission_id, new_score, feedback):
    """
    Task 3.3.3: Update assignment grades
    - Updates submission's grade object (score, feedback, gradedAt)
    - Sets status to 'graded' if not already
    - Assumes instructor is fetched for gradedBy
    """
    # Find submission
    submission = db.submissions.find_one({"submissionId": submission_id})
    if not submission:
        print(f"Submission not found: {submission_id}")
        return None

    # Fetch assignment for maxPoints
    assignment = db.assignments.find_one({"assignmentId": submission["assignmentId"]})
    if not assignment:
        print(f"Assignment not found for {submission_id}")
        return None

    # Example instructor (use a real one)
    instructor = db.users.find_one({"role": "instructor"})
    if not instructor:
        print("No instructor found")
        return None

    now = utcnow()
    # Fixed: Handle None grade safely
    grade_obj = submission.get("grade") or {}
    grade_obj.update({
        "score": new_score,
        "maxPoints": assignment["points"],
        "feedback": feedback,
        "gradedAt": now,
        "gradedByObjectId": instructor["_id"],
        "gradedById": instructor["userId"]
    })

    result = db.submissions.update_one(
        {"submissionId": submission_id},
        {
            "$set": {
                "status": "graded",
                "grade": grade_obj
            }
        }
    )

    if result.modified_count > 0:
        print(f"Grade updated for {submission_id}: {new_score}/{assignment['points']} - {feedback}")
        print(f"   Graded on: {now} by {instructor['userId']}")
        return True
    else:
        print(f"No update for submission: {submission_id}")
        return False

def task_3_3_add_tags_to_course(db, course_id, new_tags):
    """
    Task 3.3.4: Add tags to an existing course
    - Appends new tags to tags array ($push with $each for multiple)
    - Updates updatedAt
    """
    # Find course
    course = db.courses.find_one({"courseId": course_id})
    if not course:
        print(f"Course not found: {course_id}")
        return None

    now = utcnow()
    old_tags = course.get("tags", [])

    result = db.courses.update_one(
        {"courseId": course_id},
        {
            "$push": {"tags": {"$each": new_tags}},
            "$set": {"updatedAt": now}
        }
    )

    if result.modified_count > 0:
        updated_course = db.courses.find_one({"courseId": course_id})
        print(f" Tags added to {course_id}: {new_tags}")
        print(f"   Old tags: {old_tags}")
        print(f"   New all tags: {updated_course['tags']}")
        print(f"   Updated: {now}")
        return True
    else:
        print(f"No update for course: {course_id}")
        return False

def main():
    db = connect_db()

    print("=== Task 3.3: Update Operations Demo ===\n")

    # Example data from previous tasks
    user_id = "U-1020"  # New student
    course_id = "C-2008"  # New course
    submission_id = "S-6000"  # Example submission (adjust if needed)
    new_tags = ["visualization", "data-viz"]  # Tags to add

    # 1. Update user profile
    task_3_3_update_user_profile(db, user_id)

    print()  # Spacer

    # 2. Mark course as published
    task_3_3_mark_course_published(db, course_id)

    print()  # Spacer

    # 3. Update assignment grades
    task_3_3_update_assignment_grades(db, submission_id, 92, "Excellent use of libraries—minor tweaks suggested.")

    print()  # Spacer

    # 4. Add tags to course
    task_3_3_add_tags_to_course(db, course_id, new_tags)

    print("\n=== Demo Complete! Updates are atomic and respect validators. ===")
    db.client.close()

if __name__ == "__main__":
    main()

"""# PART 3.4

"""

"""
EduHub CRUD Operations - Task 3.4: Delete Operations
--------------------------------------------------
This script demonstrates DELETE operations using PyMongo:

1. Remove a user (soft delete: set isActive=False)
2. Delete an enrollment (hard delete by enrollmentId)
3. Remove a lesson from a course (hard delete lesson, decrement course lessonsCount)

Prerequisites:
- Run in Google Colab or Python env with pymongo.
- Database: eduhub_db (with data from previous tasks)

Examples use data like user U-1020, enrollment E-5144, a lesson.
"""

from pymongo import MongoClient
from datetime import datetime, timezone
from bson import ObjectId

# ---------- CONFIG ----------
MONGO_URI = "mongodb+srv://Abisola_lufadeju:Oluwafikayomibaby123.@cluster0.yy4xw2j.mongodb.net/"
DB_NAME = "eduhub_db"
# ----------------------------

def utcnow():
    return datetime.now(timezone.utc)

def connect_db():
    client = MongoClient(MONGO_URI)
    return client[DB_NAME]

def task_3_4_soft_delete_user(db, user_id):
    """
    Task 3.4.1: Soft delete a user (set isActive=False)
    - Updates the user document without removing it
    """
    # Find user first
    user = db.users.find_one({"userId": user_id})
    if not user:
        print(f"User not found: {user_id}")
        return None

    if not user["isActive"]:
        print(f"User {user_id} is already inactive")
        return True

    result = db.users.update_one(
        {"userId": user_id},
        {"$set": {"isActive": False}}
    )

    if result.modified_count > 0:
        print(f"User {user_id} soft-deleted (isActive=False)")
        return True
    else:
        print(f"Failed to soft-delete user: {user_id}")
        return False

def task_3_4_delete_enrollment(db, enrollment_id):
    """
    Task 3.4.2: Delete an enrollment
    - Hard delete by enrollmentId
    """
    # Find enrollment first
    enrollment = db.enrollments.find_one({"enrollmentId": enrollment_id})
    if not enrollment:
        print(f"Enrollment not found: {enrollment_id}")
        return None

    result = db.enrollments.delete_one({"enrollmentId": enrollment_id})

    if result.deleted_count > 0:
        print(f"Enrollment {enrollment_id} deleted")
        print(f"   (Was for student {enrollment['studentId']} in course {enrollment['courseId']})")
        return True
    else:
        print(f"Failed to delete enrollment: {enrollment_id}")
        return False

def task_3_4_remove_lesson(db, lesson_id):
    """
    Task 3.4.3: Remove a lesson from a course
    - Hard delete the lesson document
    - Decrements the course's lessonsCount
    """
    # Find lesson first
    lesson = db.lessons.find_one({"lessonId": lesson_id})
    if not lesson:
        print(f"Lesson not found: {lesson_id}")
        return None

"""# PART 4.1"""

"""
EduHub CRUD Operations - Task 4.1: Complex Queries
-------------------------------------------------
This script demonstrates complex queries using PyMongo operators:

1. Find courses with price between $50 and $200 ($gt, $lt)
2. Get users who joined in the last 6 months ($gte on date)
3. Find courses that have specific tags using $in operator (array contains match)
4. Retrieve assignments with due dates in the next week ($gte, $lte on date)

Prerequisites:
- Run in Google Colab or Python env with pymongo.
- Database: eduhub_db (with data from previous tasks)

Current date: October 05, 2025 (used for date calculations).
"""

from pymongo import MongoClient
from datetime import datetime, timedelta, timezone
from bson import ObjectId
import random

# ---------- CONFIG ----------
MONGO_URI = "mongodb+srv://Abisola_lufadeju:Oluwafikayomibaby123.@cluster0.yy4xw2j.mongodb.net/"
DB_NAME = "eduhub_db"
# ----------------------------

def utcnow():
    return datetime.now(timezone.utc)

def connect_db():
    client = MongoClient(MONGO_URI)
    return client[DB_NAME]

def task_4_1_courses_by_price_range(db, min_price=50, max_price=200):
    """
    Task 4.1.1: Find courses with price between $50 and $200
    - Uses $gt and $lt operators
    - Sorts by price ascending
    """
    courses = list(db.courses.find({
        "price": {"$gt": min_price, "$lt": max_price}
    }).sort("price", 1))

    if courses:
        print(f"Courses priced ${min_price} - ${max_price}: {len(courses)} found")
        for course in courses[:3]:  # Limit to 3
            print(f"   - {course['title']} (Category: {course['category']}, Price: ${course['price']})")
        if len(courses) > 3:
            print(f"   ... and {len(courses) - 3} more")
        return courses
    else:
        print(f"No courses in price range ${min_price} - ${max_price}")
        return []

def task_4_1_users_last_6_months(db, months=6):
    """
    Task 4.1.2: Get users who joined in the last 6 months
    - Calculates cutoff date: now - 6 months (approx 180 days)
    - Uses $gte on dateJoined, filters students/instructors
    """
    cutoff_date = utcnow() - timedelta(days=180)  # Approx 6 months
    users = list(db.users.find({
        "dateJoined": {"$gte": cutoff_date},
        "isActive": True
    }).sort("dateJoined", -1))  # Newest first

    if users:
        print(f"Users joined since {cutoff_date.strftime('%Y-%m-%d')}: {len(users)} active found")
        for user in users[:3]:
            role = user["role"]
            print(f"   - {user['firstName']} {user['lastName']} ({role}, Joined: {user['dateJoined'].strftime('%Y-%m-%d')})")
        if len(users) > 3:
            print(f"   ... and {len(users) - 3} more")
        return users
    else:
        print(f"No users joined in last {months} months")
        return []

def task_4_1_courses_with_specific_tags(db, tags_list):
    """
    Task 4.1.3: Find courses that have specific tags using $in operator
    - Matches if tags array contains any of the specified tags ($in)
    - Sorts by title
    """
    courses = list(db.courses.find({
        "tags": {"$in": tags_list}
    }).sort("title", 1))

    if courses:
        print(f"Courses with tags {tags_list}: {len(courses)} found")
        for course in courses[:3]:
            matching_tags = [tag for tag in course["tags"] if tag in tags_list]
            print(f"   - {course['title']} (Matching tags: {matching_tags})")
        if len(courses) > 3:
            print(f"   ... and {len(courses) - 3} more")
        return courses
    else:
        print(f"No courses with tags: {tags_list}")
        return []

def task_4_1_assignments_next_week(db, days=7):
    """
    Task 4.1.4: Retrieve assignments with due dates in the next week
    - Uses $gte and $lte on dueAt (now to now + 7 days)
    - Sorts by dueAt ascending (soonest first)
    """
    now = utcnow()
    next_week = now + timedelta(days=days)
    assignments = list(db.assignments.find({
        "dueAt": {"$gte": now, "$lte": next_week}
    }).sort("dueAt", 1))

    if assignments:
        print(f"Assignments due {now.strftime('%Y-%m-%d')} to {next_week.strftime('%Y-%m-%d')}: {len(assignments)} found")
        for assign in assignments[:3]:
            print(f"   - {assign['title']} (Course: {assign['courseId']}, Due: {assign['dueAt'].strftime('%Y-%m-%d')}, Points: {assign['points']})")
        if len(assignments) > 3:
            print(f"   ... and {len(assignments) - 3} more")
        return assignments
    else:
        print(f"No assignments due in next {days} days")
        return []

def main():
    db = connect_db()

    print("=== Task 4.1: Complex Queries Demo ===\n")

    # Examples
    price_min, price_max = 50, 200
    months_back = 6
    tags_example = ["python", "mongodb"]
    days_ahead = 7

    # 1. Courses by price range
    task_4_1_courses_by_price_range(db, price_min, price_max)

    print()  # Spacer

    # 2. Users last 6 months
    task_4_1_users_last_6_months(db, months_back)

    print()  # Spacer

    # 3. Courses with specific tags
    task_4_1_courses_with_specific_tags(db, tags_example)

    print()  # Spacer

    # 4. Assignments next week
    task_4_1_assignments_next_week(db, days_ahead)

    print("\n=== Demo Complete! Queries use operators like $gt, $in, $gte for efficiency. ===")
    db.client.close()

if __name__ == "__main__":
    main()

"""# PART 4.2"""

"""
EduHub CRUD Operations - Task 4.2: Aggregation Pipelines
-------------------------------------------------------
This script demonstrates aggregation pipelines using PyMongo for advanced analytics:

1. Course Enrollment Statistics:
   - Count total enrollments per course
   - Calculate average course rating (avg grade from submissions)
   - Group by course category (enrollments count)

2. Student Performance Analysis:
   - Average grade per student (from graded submissions)
   - Completion rate by course (% completed enrollments)
   - Top-performing students (by avg progress in enrollments)

3. Instructor Analytics:
   - Total students taught by each instructor (unique from enrollments)
   - Average course rating per instructor (avg grades in their courses)
   - Revenue generated per instructor (sum price * completed enrollments)

4. Advanced Analytics:
   - Monthly enrollment trends (count by month/year)
   - Most popular course categories (enrollments count)
   - Student engagement metrics (avg submissions per student)

Prerequisites:
- Run in Google Colab or Python env with pymongo.
- Database: eduhub_db (with seeded + CRUD data)

Assumptions:
- Ratings from submission grades (score / maxPoints * 100).
- Completion: status='completed' or progress=100.
- Revenue: price per completed enrollment.
- Engagement: count submissions per student.
"""

from pymongo import MongoClient
from datetime import datetime, timezone
from bson import ObjectId

# ---------- CONFIG ----------
MONGO_URI = "mongodb+srv://Abisola_lufadeju:Oluwafikayomibaby123.@cluster0.yy4xw2j.mongodb.net/"
DB_NAME = "eduhub_db"
# ----------------------------

def connect_db():
    client = MongoClient(MONGO_URI)
    return client[DB_NAME]

def task_4_2_enrollments_per_course(db):
    """
    1a. Count total enrollments per course
    - Groups enrollments by courseId, counts
    - Joins with courses for title
    """
    pipeline = [
        {"$group": {"_id": "$courseId", "totalEnrollments": {"$sum": 1}}},
        {"$lookup": {"from": "courses", "localField": "_id", "foreignField": "courseId", "as": "course"}},
        {"$unwind": "$course"},
        {"$project": {"courseTitle": "$course.title", "totalEnrollments": 1}},
        {"$sort": {"totalEnrollments": -1}}
    ]
    results = list(db.enrollments.aggregate(pipeline))
    print("=== 1a. Total Enrollments per Course ===")
    for res in results[:5]:  # Top 5
        print(f"- {res['courseTitle']}: {res['totalEnrollments']} enrollments")
    return results

def task_4_2_average_course_rating(db):
    """
    1b. Calculate average course rating
    - Joins submissions to assignments to courses
    - Averages (score / maxPoints * 100) per course
    """
    pipeline = [
        {"$lookup": {"from": "assignments", "localField": "assignmentObjectId", "foreignField": "_id", "as": "assignment"}},
        {"$unwind": "$assignment"},
        {"$lookup": {"from": "courses", "localField": "assignment.courseObjectId", "foreignField": "_id", "as": "course"}},
        {"$unwind": "$course"},
        {"$match": {"grade.score": {"$ne": None}}},  # Only graded
        {"$group": {
            "_id": "$course.courseId",
            "courseTitle": {"$first": "$course.title"},
            "avgRating": {"$avg": {"$multiply": [{"$divide": ["$grade.score", "$grade.maxPoints"]}, 100]}}
        }},
        {"$sort": {"avgRating": -1}}
    ]
    results = list(db.submissions.aggregate(pipeline))
    print("\n=== 1b. Average Course Rating (Top 5) ===")
    for res in results[:5]:
        print(f"- {res['courseTitle']}: {res['avgRating']:.1f}%")
    return results

def task_4_2_group_by_category(db):
    """
    1c. Group by course category (enrollments count)
    - Joins enrollments to courses, groups by category
    """
    pipeline = [
        {"$lookup": {"from": "courses", "localField": "courseObjectId", "foreignField": "_id", "as": "course"}},
        {"$unwind": "$course"},
        {"$group": {"_id": "$course.category", "totalEnrollments": {"$sum": 1}}},
        {"$sort": {"totalEnrollments": -1}}
    ]
    results = list(db.enrollments.aggregate(pipeline))
    print("\n=== 1c. Enrollments by Category ===")
    for res in results:
        print(f"- {res['_id']}: {res['totalEnrollments']} enrollments")
    return results

def task_4_2_avg_grade_per_student(db):
    """
    2a. Average grade per student
    - Groups submissions by studentId, averages (score / maxPoints * 100)
    """
    pipeline = [
        {"$lookup": {"from": "assignments", "localField": "assignmentObjectId", "foreignField": "_id", "as": "assignment"}},
        {"$unwind": "$assignment"},
        {"$match": {"grade.score": {"$ne": None}}},
        {"$group": {
            "_id": "$studentId",
            "avgGrade": {"$avg": {"$multiply": [{"$divide": ["$grade.score", "$grade.maxPoints"]}, 100]}}
        }},
        {"$sort": {"avgGrade": -1}}
    ]
    results = list(db.submissions.aggregate(pipeline))
    print("\n=== 2a. Average Grade per Student (Top 5) ===")
    for res in results[:5]:
        print(f"- Student {res['_id']}: {res['avgGrade']:.1f}%")
    return results

def task_4_2_completion_rate_by_course(db):
    """
    2b. Completion rate by course
    - Counts completed vs total enrollments per course
    - Completion: status='completed'
    """
    pipeline = [
        {"$group": {
            "_id": "$courseId",
            "total": {"$sum": 1},
            "completed": {"$sum": {"$cond": [{"$eq": ["$status", "completed"]}, 1, 0]}}
        }},
        {"$lookup": {"from": "courses", "localField": "_id", "foreignField": "courseId", "as": "course"}},
        {"$unwind": "$course"},
        {"$addFields": {"completionRate": {"$multiply": [{"$divide": ["$completed", "$total"]}, 100]}}},
        {"$sort": {"completionRate": -1}},
        {"$project": {"courseTitle": "$course.title", "completionRate": 1}}
    ]
    results = list(db.enrollments.aggregate(pipeline))
    print("\n=== 2b. Completion Rate by Course (Top 5) ===")
    for res in results[:5]:
        print(f"- {res['courseTitle']}: {res['completionRate']:.1f}%")
    return results

def task_4_2_top_performing_students(db):
    """
    2c. Top-performing students (by avg progress)
    - Averages progress.percent per student
    """
    pipeline = [
        {"$group": {
            "_id": "$studentId",
            "avgProgress": {"$avg": "$progress.percent"}
        }},
        {"$lookup": {"from": "users", "localField": "_id", "foreignField": "userId", "as": "student"}},
        {"$unwind": "$student"},
        {"$addFields": {"studentName": {"$concat": ["$student.firstName", " ", "$student.lastName"]}}},
        {"$sort": {"avgProgress": -1}},
        {"$limit": 5},
        {"$project": {"studentName": 1, "avgProgress": 1}}
    ]
    results = list(db.enrollments.aggregate(pipeline))
    print("\n=== 2c. Top-Performing Students ===")
    for res in results:
        print(f"- {res['studentName']}: {res['avgProgress']:.1f}% avg progress")
    return results

def task_4_2_students_per_instructor(db):
    """
    3a. Total students taught by each instructor
    - Joins enrollments to courses to instructors, counts unique students
    """
    pipeline = [
        {"$lookup": {"from": "courses", "localField": "courseObjectId", "foreignField": "_id", "as": "course"}},
        {"$unwind": "$course"},
        {"$group": {
            "_id": "$course.instructorId",
            "uniqueStudents": {"$addToSet": "$studentId"}
        }},
        {"$lookup": {"from": "users", "localField": "_id", "foreignField": "userId", "as": "instructor"}},
        {"$unwind": "$instructor"},
        {"$addFields": {"instructorName": {"$concat": ["$instructor.firstName", " ", "$instructor.lastName"]}}},
        {"$project": {"instructorName": 1, "totalStudents": {"$size": "$uniqueStudents"}}},
        {"$sort": {"totalStudents": -1}}
    ]
    results = list(db.enrollments.aggregate(pipeline))
    print("\n=== 3a. Total Students per Instructor (Top 3) ===")
    for res in results[:3]:
        print(f"- {res['instructorName']}: {res['totalStudents']} students")
    return results

def task_4_2_avg_rating_per_instructor(db):
    """
    3b. Average course rating per instructor
    - Joins submissions through assignments/courses to instructors
    """
    pipeline = [
        {"$lookup": {"from": "assignments", "localField": "assignmentObjectId", "foreignField": "_id", "as": "assignment"}},
        {"$unwind": "$assignment"},
        {"$lookup": {"from": "courses", "localField": "assignment.courseObjectId", "foreignField": "_id", "as": "course"}},
        {"$unwind": "$course"},
        {"$match": {"grade.score": {"$ne": None}}},
        {"$group": {
            "_id": "$course.instructorId",
            "avgRating": {"$avg": {"$multiply": [{"$divide": ["$grade.score", "$grade.maxPoints"]}, 100]}}
        }},
        {"$lookup": {"from": "users", "localField": "_id", "foreignField": "userId", "as": "instructor"}},
        {"$unwind": "$instructor"},
        {"$addFields": {"instructorName": {"$concat": ["$instructor.firstName", " ", "$instructor.lastName"]}}},
        {"$sort": {"avgRating": -1}}
    ]
    results = list(db.submissions.aggregate(pipeline))
    print("\n=== 3b. Average Rating per Instructor (Top 3) ===")
    for res in results[:3]:
        print(f"- {res['instructorName']}: {res['avgRating']:.1f}%")
    return results

def task_4_2_revenue_per_instructor(db):
    """
    3c. Revenue generated per instructor
    - Joins enrollments to courses (only completed), sums price per instructor
    """
    pipeline = [
        {"$match": {"status": "completed"}},
        {"$lookup": {"from": "courses", "localField": "courseObjectId", "foreignField": "_id", "as": "course"}},
        {"$unwind": "$course"},
        {"$group": {
            "_id": "$course.instructorId",
            "totalRevenue": {"$sum": "$course.price"}
        }},
        {"$lookup": {"from": "users", "localField": "_id", "foreignField": "userId", "as": "instructor"}},
        {"$unwind": "$instructor"},
        {"$addFields": {"instructorName": {"$concat": ["$instructor.firstName", " ", "$instructor.lastName"]}}},
        {"$sort": {"totalRevenue": -1}}
    ]
    results = list(db.enrollments.aggregate(pipeline))
    print("\n=== 3c. Revenue per Instructor (Top 3) ===")
    for res in results[:3]:
        print(f"- {res['instructorName']}: ${res['totalRevenue']:.2f}")
    return results

def task_4_2_monthly_enrollment_trends(db):
    """
    4a. Monthly enrollment trends
    - Groups by year-month from enrolledAt, counts
    """
    pipeline = [
        {"$addFields": {
            "yearMonth": {"$dateToString": {"format": "%Y-%m", "date": "$enrolledAt"}}
        }},
        {"$group": {"_id": "$yearMonth", "enrollments": {"$sum": 1}}},
        {"$sort": {"_id": 1}}
    ]
    results = list(db.enrollments.aggregate(pipeline))
    print("\n=== 4a. Monthly Enrollment Trends ===")
    for res in results[-6:]:  # Last 6 months
        print(f"- {res['_id']}: {res['enrollments']} enrollments")
    return results

def task_4_2_popular_categories(db):
    """
    4b. Most popular course categories
    - Counts enrollments per category
    """
    pipeline = [
        {"$lookup": {"from": "courses", "localField": "courseObjectId", "foreignField": "_id", "as": "course"}},
        {"$unwind": "$course"},
        {"$group": {"_id": "$course.category", "enrollments": {"$sum": 1}}},
        {"$sort": {"enrollments": -1}},
        {"$limit": 5}
    ]
    results = list(db.enrollments.aggregate(pipeline))
    print("\n=== 4b. Most Popular Categories ===")
    for res in results:
        print(f"- {res['_id']}: {res['enrollments']} enrollments")
    return results

def task_4_2_student_engagement(db):
    """
    4c. Student engagement metrics (avg submissions per student)
    - Counts submissions per student, averages
    """
    pipeline = [
        {"$group": {
            "_id": "$studentId",
            "submissionCount": {"$sum": 1}
        }},
        {"$group": {
            "_id": None,
            "avgSubmissionsPerStudent": {"$avg": "$submissionCount"},
            "totalStudents": {"$sum": 1}
        }}
    ]
    results = list(db.submissions.aggregate(pipeline))
    if results:
        res = results[0]
        print(f"\n=== 4c. Student Engagement Metrics ===")
        print(f"- Average submissions per student: {res['avgSubmissionsPerStudent']:.1f}")
        print(f"- Total students with submissions: {res['totalStudents']}")
    return results

def main():
    db = connect_db()

    print("=== Task 4.2: Aggregation Pipelines Demo ===\n")

    # Section 1: Course Enrollment Statistics
    task_4_2_enrollments_per_course(db)
    task_4_2_average_course_rating(db)
    task_4_2_group_by_category(db)

    # Section 2: Student Performance Analysis
    task_4_2_avg_grade_per_student(db)
    task_4_2_completion_rate_by_course(db)
    task_4_2_top_performing_students(db)

    # Section 3: Instructor Analytics
    task_4_2_students_per_instructor(db)
    task_4_2_avg_rating_per_instructor(db)
    task_4_2_revenue_per_instructor(db)

    # Section 4: Advanced Analytics
    task_4_2_monthly_enrollment_trends(db)
    task_4_2_popular_categories(db)
    task_4_2_student_engagement(db)

    print("\n=== All Aggregations Complete! Pipelines use $group, $lookup, $match for insights. ===")
    db.client.close()

if __name__ == "__main__":
    main()

"""#PART 5.1

"""

"""
EduHub CRUD Operations - Task 5.1: Index Creation
------------------------------------------------
This script creates appropriate MongoDB indexes for performance:

1. User email lookup: Unique index on 'email' (fast equality queries)
2. Course search by title and category: Compound index on 'title' (text) and 'category' (for combined searches)
3. Assignment queries by due date: Ascending index on 'dueAt' (efficient range/sort queries)
4. Enrollment queries by student and course: Compound unique index on 'studentObjectId' and 'courseObjectId' (prevents duplicates, fast lookups)

Prerequisites:
- Run in Google Colab or Python env with pymongo.
- Database: eduhub_db (existing collections)

Indexes are idempotent (safe to run multiple times).
"""

from pymongo import MongoClient, ASCENDING, DESCENDING, TEXT

# ---------- CONFIG ----------
MONGO_URI = "mongodb+srv://Abisola_lufadeju:Oluwafikayomibaby123.@cluster0.yy4xw2j.mongodb.net/"
DB_NAME = "eduhub_db"
# ----------------------------

def connect_db():
    client = MongoClient(MONGO_URI)
    return client[DB_NAME]

def create_indexes(db):
    """
    Create all required indexes
    """
    print("=== Task 5.1: Creating Indexes ===\n")

    # 1. User email lookup: Unique ascending index
    try:
        db.users.create_index([("email", ASCENDING)], unique=True, name="idx_user_email_unique")
        print("Created unique index on users.email")
    except Exception as e:
        print(f"Index on users.email already exists or error: {e}")

    # 2. Course search by title and category: Compound index (text on title for partial search, category ascending)
    # Note: For full-text search on title, use text index; compound for filtered searches
    try:
        # Text index on title for search
        db.courses.create_index([("title", TEXT)], name="idx_course_title_text")
        # Compound for category + title
        db.courses.create_index([("category", ASCENDING), ("title", ASCENDING)], name="idx_course_category_title")
        print("Created text index on courses.title and compound on category+title")
    except Exception as e:
        print(f"Indexes on courses.title/category already exist or error: {e}")

    # 3. Assignment queries by due date: Ascending index for range queries
    try:
        db.assignments.create_index([("dueAt", ASCENDING)], name="idx_assignment_dueAt")
        print("Created ascending index on assignments.dueAt")
    except Exception as e:
        print(f"Index on assignments.dueAt already exists or error: {e}")

    # 4. Enrollment queries by student and course: Compound unique index
    try:
        db.enrollments.create_index([("studentObjectId", ASCENDING), ("courseObjectId", ASCENDING)], unique=True, name="idx_enrollment_student_course_unique")
        print("Created unique compound index on enrollments.studentObjectId + courseObjectId")
    except Exception as e:
        print(f"Index on enrollments.student+course already exists or error: {e}")

    print("\n=== All Indexes Created! Use explain() to verify usage. ===")

def main():
    db = connect_db()
    create_indexes(db)
    db.client.close()

if __name__ == "__main__":
    main()

"""#TASK 5.2"""

"""
EduHub CRUD Operations - Task 5.2: Query Optimization
---------------------------------------------------
This script analyzes query performance using .explain("executionStats"),
optimizes 3 queries by adding indexes, and documents improvements with timing.

Queries Optimized:
1. Find courses with a specific tag (e.g., 'python') - Add index on 'tags'.
2. Find enrollments for a student sorted by enrolledAt - Add compound index on 'studentId' + 'enrolledAt'.
3. Aggregate average progress by course category - Add index on 'courseObjectId' for efficient lookup.

Run in Google Colab/Python env with pymongo. Indexes are added if missing.
Timings and explain outputs are printed for before/after comparison.
"""

from pymongo import MongoClient
import time
from datetime import datetime, timezone
from bson import ObjectId

# ---------- CONFIG ----------
MONGO_URI = "mongodb+srv://Abisola_lufadeju:Oluwafikayomibaby123.@cluster0.yy4xw2j.mongodb.net/"
DB_NAME = "eduhub_db"
# ----------------------------

def connect_db():
    client = MongoClient(MONGO_URI)
    return client[DB_NAME]

# Helper for find queries
def analyze_find_query(db, collection, find_query, name, index_name=None):
    # Drop index if exists for 'before'
    if index_name:
        try:
            getattr(db, collection).drop_index(index_name)
        except:
            pass

    start_time = time.time()
    cursor = getattr(db, collection).find(find_query)
    explain_result = cursor.explain("executionStats")
    results = list(cursor)
    end_time = time.time()
    duration = end_time - start_time

    print(f"=== {name} (Before Optimization) ===")
    print(f"Duration: {duration:.4f}s")
    print(f"Docs Examined: {explain_result['executionStats'].get('totalDocsExamined', 'N/A')}")
    print(f"Stage: {explain_result['executionStats']['executionStages'][0].get('stage', 'COLLSCAN')}")

    return duration, explain_result, results

def optimize_and_analyze_find(db, collection, find_query, index_keys, index_name, name):
    # Before
    duration_before, explain_before, results_before = analyze_find_query(db, collection, find_query, f"{name} Before", index_name)

    # Add index
    getattr(db, collection).create_index(index_keys, name=index_name)

    # After
    start_time = time.time()
    cursor = getattr(db, collection).find(find_query)
    explain_after = cursor.explain("executionStats")
    results_after = list(cursor)
    end_time = time.time()
    duration_after = end_time - start_time

    print(f"=== {name} (After Optimization) ===")
    print(f"Duration: {duration_after:.4f}s")
    print(f"Docs Examined: {explain_after['executionStats'].get('totalDocsExamined', 'N/A')}")
    print(f"Stage: {explain_after['executionStats']['executionStages'][0].get('stage', 'IXSCAN')}")

    improvement = ((duration_before - duration_after) / duration_before * 100) if duration_before > 0 else 0
    print(f"Performance Improvement: {improvement:.1f}% faster")
    print(f"Results Count: {len(results_after)} (unchanged)")
    print("-" * 50)

# Helper for aggregate
def analyze_aggregate(db, collection, pipeline, name, index_name=None):
    # Drop index if exists
    if index_name:
        try:
            getattr(db, collection).drop_index(index_name)
        except:
            pass

    start_time = time.time()
    cursor = getattr(db, collection).aggregate(pipeline)
    explain_result = cursor.explain("executionStats")
    results = list(cursor)
    end_time = time.time()
    duration = end_time - start_time

    print(f"=== {name} (Before Optimization) ===")
    print(f"Duration: {duration:.4f}s")
    print(f"Docs Examined: {explain_result.get('executionStats', {}).get('totalDocsExamined', 'N/A')}")
    print(f"Stage: {explain_result.get('executionStats', {}).get('executionStages', [{}])[0].get('stage', 'COLLSCAN')}")

    return duration, explain_result, results

def optimize_and_analyze_aggregate(db, collection, pipeline, index_keys, index_name, name):
    # Before
    duration_before, explain_before, results_before = analyze_aggregate(db, collection, pipeline, f"{name} Before", index_name)

    # Add index
    getattr(db, collection).create_index(index_keys, name=index_name)

    # After
    start_time = time.time()
    cursor = getattr(db, collection).aggregate(pipeline)
    explain_after = cursor.explain("executionStats")
    results_after = list(cursor)
    end_time = time.time()
    duration_after = end_time - start_time

    print(f"=== {name} (After Optimization) ===")
    print(f"Duration: {duration_after:.4f}s")
    print(f"Docs Examined: {explain_after.get('executionStats', {}).get('totalDocsExamined', 'N/A')}")
    print(f"Stage: {explain_after.get('executionStats', {}).get('executionStages', {}).get('stage', 'N/A')}")

"""#PART 6

"""

"""
EduHub CRUD Operations - Task 6.1: Schema Validation
--------------------------------------------------
This script implements/enhances JSON schema validators for MongoDB collections
with focus on:
- Required fields (e.g., email, title)
- Data type validation (e.g., string, objectId, date, number)
- Enum value restrictions (e.g., role: ['student', 'instructor'], status enums)
- Email format validation (regex pattern for users.email)

Updates existing collections via collMod or creates if missing.
Prerequisites:
- Run in Google Colab or Python env with pymongo.
- Database: eduhub_db (existing collections)
"""

from pymongo import MongoClient, errors
from datetime import datetime, timezone
from bson import ObjectId

# ---------- CONFIG ----------
MONGO_URI = "mongodb+srv://Abisola_lufadeju:Oluwafikayomibaby123.@cluster0.yy4xw2j.mongodb.net/"
DB_NAME = "eduhub_db"
# ----------------------------

def utcnow():
    return datetime.now(timezone.utc)

def connect_db():
    client = MongoClient(MONGO_URI)
    return client[DB_NAME]

def update_or_create_validator(db, collection_name, schema):
    """
    Update or create collection with $jsonSchema validator
    """
    try:
        # Try to create
        db.create_collection(collection_name, validator={"$jsonSchema": schema})
        print(f"Created collection '{collection_name}' with validator")
    except errors.CollectionInvalid:
        # Update existing
        db.command("collMod", collection_name, validator={"$jsonSchema": schema})
        print(f"Updated validator for '{collection_name}'")

def main():
    db = connect_db()

    print("=== Task 6.1: Implementing Schema Validation ===\n")

    # 1. Users Schema: Required fields (email, firstName, etc.), types, enum (role), email pattern
    users_schema = {
        "bsonType": "object",
        "required": ["email", "firstName", "lastName", "role", "dateJoined"],  # Required fields
        "properties": {
            "userId": {"bsonType": "string"},  # Data type: string
            "email": {
                "bsonType": "string",
                "pattern": r"^[^@\s]+@[^@\s]+\.[^@\s]+$"  # Email format validation
            },
            "firstName": {"bsonType": "string", "minLength": 1},  # Data type + min length
            "lastName": {"bsonType": "string", "minLength": 1},
            "role": {"enum": ["student", "instructor"]},  # Enum restriction
            "dateJoined": {"bsonType": "date"},  # Data type: date
            "profile": {
                "bsonType": "object",  # Nested object type
                "properties": {
                    "bio": {"bsonType": "string"},
                    "avatar": {"bsonType": "string"},
                    "skills": {"bsonType": "array", "items": {"bsonType": "string"}}
                }
            },
            "isActive": {"bsonType": "bool"}  # Data type: bool
        },
        "additionalProperties": True
    }
    update_or_create_validator(db, "users", users_schema)

    print()  # Spacer

    # 2. Courses Schema: Required (title, instructorObjectId), types, enum (level)
    courses_schema = {
        "bsonType": "object",
        "required": ["title", "instructorObjectId", "createdAt"],  # Required fields
        "properties": {
            "courseId": {"bsonType": "string"},
            "title": {"bsonType": "string", "minLength": 1},  # Data type + min length
            "description": {"bsonType": "string"},
            "instructorObjectId": {"bsonType": "objectId"},  # Data type: objectId
            "instructorId": {"bsonType": "string"},
            "category": {"bsonType": "string"},
            "level": {"enum": ["beginner", "intermediate", "advanced"]},  # Enum restriction
            "duration": {"bsonType": ["double", "int"], "minimum": 0},  # Data type + min value
            "price": {"bsonType": ["double", "int"], "minimum": 0},
            "tags": {"bsonType": "array", "items": {"bsonType": "string"}},
            "createdAt": {"bsonType": "date"},  # Data type: date
            "updatedAt": {"bsonType": "date"},
            "isPublished": {"bsonType": "bool"}  # Data type: bool
        },
        "additionalProperties": True
    }
    update_or_create_validator(db, "courses", courses_schema)

    print()  # Spacer

    # 3. Enrollments Schema: Required (studentObjectId, etc.), types, enum (status)
    enrollments_schema = {
        "bsonType": "object",
        "required": ["studentObjectId", "courseObjectId", "enrolledAt", "status"],  # Required fields
        "properties": {
            "enrollmentId": {"bsonType": "string"},
            "studentObjectId": {"bsonType": "objectId"},  # Data type: objectId
            "studentId": {"bsonType": "string"},
            "courseObjectId": {"bsonType": "objectId"},
            "courseId": {"bsonType": "string"},
            "enrolledAt": {"bsonType": "date"},  # Data type: date
            "status": {"enum": ["active", "completed", "dropped"]},  # Enum restriction
            "progress": {
                "bsonType": "object",  # Nested object type
                "properties": {
                    "percent": {"bsonType": "double", "minimum": 0, "maximum": 100},  # Data type + range
                    "lastLessonObjectId": {"bsonType": ["objectId", "null"]},
                    "lastUpdated": {"bsonType": "date"}
                }
            }
        },
        "additionalProperties": True
    }
    update_or_create_validator(db, "enrollments", enrollments_schema)

    print()  # Spacer

    # 4. Assignments Schema: Required (courseObjectId, etc.), types, enum (none here, but types)
    assignments_schema = {
        "bsonType": "object",
        "required": ["courseObjectId", "title", "points", "createdAt"],  # Required fields
        "properties": {
            "assignmentId": {"bsonType": "string"},
            "courseObjectId": {"bsonType": "objectId"},  # Data type: objectId
            "courseId": {"bsonType": "string"},
            "lessonObjectId": {"bsonType": ["objectId", "null"]},
            "lessonId": {"bsonType": ["string", "null"]},
            "title": {"bsonType": "string", "minLength": 1},  # Data type + min length
            "description": {"bsonType": "string"},
            "dueAt": {"bsonType": "date"},  # Data type: date
            "points": {"bsonType": "int", "minimum": 0},  # Data type + min value
            "createdAt": {"bsonType": "date"},
            "updatedAt": {"bsonType": "date"}
        },
        "additionalProperties": True
    }
    update_or_create_validator(db, "assignments", assignments_schema)

    print()  # Spacer

    # 5. Submissions Schema: Required (assignmentObjectId, etc.), types, enum (status)
    submissions_schema = {
        "bsonType": "object",
        "required": ["assignmentObjectId", "studentObjectId", "submittedAt", "status"],  # Required fields
        "properties": {
            "submissionId": {"bsonType": "string"},
            "assignmentObjectId": {"bsonType": "objectId"},  # Data type: objectId
            "assignmentId": {"bsonType": "string"},
            "studentObjectId": {"bsonType": "objectId"},
            "studentId": {"bsonType": "string"},
            "submittedAt": {"bsonType": "date"},  # Data type: date
            "status": {"enum": ["submitted", "graded", "resubmitted", "late"]},  # Enum restriction
            "files": {"bsonType": "array", "items": {"bsonType": "string"}},  # Array type
            "grade": {
                "bsonType": ["object", "null"],  # Optional object
                "properties": {
                    "score": {"bsonType": "double", "minimum": 0},  # Data type + min
                    "maxPoints": {"bsonType": "int", "minimum": 0},
                    "feedback": {"bsonType": "string"},
                    "gradedAt": {"bsonType": "date"},
                    "gradedByObjectId": {"bsonType": "objectId"},
                    "gradedById": {"bsonType": "string"}
                }
            }
        },
        "additionalProperties": True
    }
    update_or_create_validator(db, "submissions", submissions_schema)

    print("\n=== Schema Validation Implemented! Test with invalid inserts to verify errors. ===")
    db.client.close()

if __name__ == "__main__":
    main()

"""# PART 6.2"""

"""
EduHub CRUD Operations - Task 6.2: Error Handling
------------------------------------------------
This script demonstrates handling common MongoDB errors in PyMongo:

1. Duplicate key errors (e.g., unique email violation)
2. Invalid data type insertions (e.g., wrong type for ObjectId)
3. Missing required fields (e.g., omit required 'email')

Uses try-except blocks to catch and handle errors gracefully.
Prerequisites:
- Run in Google Colab or Python env with pymongo.
- Database: eduhub_db (with validators from Task 6.1)
"""

from pymongo import MongoClient, errors
from datetime import datetime, timezone
from bson import ObjectId

# ---------- CONFIG ----------
MONGO_URI = "mongodb+srv://Abisola_lufadeju:Oluwafikayomibaby123.@cluster0.yy4xw2j.mongodb.net/"
DB_NAME = "eduhub_db"
# ----------------------------

def utcnow():
    return datetime.now(timezone.utc)

def connect_db():
    client = MongoClient(MONGO_URI)
    return client[DB_NAME]

def handle_duplicate_key_error():
    """
    Task 6.2.1: Handle Duplicate Key Errors
    - Tries to insert user with existing email
    - Catches DuplicateKeyError, generates new email
    """
    db = connect_db()

    # Assume existing email from seeded data
    existing_email = "ife.aluko0@eduhub.local"

    new_user = {
        "userId": "U-DUP1",
        "email": existing_email,  # Duplicate
        "firstName": "Duplicate",
        "lastName": "Test",
        "role": "student",
        "dateJoined": utcnow(),
        "profile": {"bio": "Test bio"},
        "isActive": True
    }

    try:
        db.users.insert_one(new_user)
        print("✅ Insert successful (unexpected - no duplicate?)")
    except errors.DuplicateKeyError as e:
        print(f"❌ DuplicateKeyError caught: {e}")
        print("   Handling: Generating new email...")
        # Handle: Modify email and retry
        new_email = existing_email.replace("@", "_retry@")
        new_user["email"] = new_email
        try:
            result = db.users.insert_one(new_user)
            print(f"✅ Retry successful with new email: {new_email} (_id: {result.inserted_id})")
        except Exception as retry_e:
            print(f"❌ Retry failed: {retry_e}")

    db.client.close()

def handle_invalid_data_type_error():
    """
    Task 6.2.2: Handle Invalid Data Type Insertions
    - Tries to insert invalid ObjectId for instructorObjectId
    - Catches WriteError (validation failure)
    """
    db = connect_db()

    new_course = {
        "courseId": "C-INVALID",
        "title": "Invalid Type Course",
        "description": "Test invalid ObjectId",
        "instructorObjectId": "invalid-string-id",  # Wrong type (should be ObjectId)
        "instructorId": "U-1000",
        "category": "programming",
        "level": "beginner",
        "duration": 5.0,
        "price": 99.99,
        "tags": ["test"],
        "createdAt": utcnow(),
        "updatedAt": utcnow(),
        "isPublished": True,
        "lessonsCount": 0
    }

    try:
        db.courses.insert_one(new_course)
        print("Insert successful (unexpected - no type error?)")
    except errors.WriteError as e:
        print(f"WriteError (Invalid Type) caught: {e}")
        print("   Handling: Convert to valid ObjectId or skip...")
        # Handle: Fetch valid instructor ObjectId
        instructor = db.users.find_one({"userId": "U-1000"})
        if instructor:
            new_course["instructorObjectId"] = instructor["_id"]  # Fix type
            try:
                result = db.courses.insert_one(new_course)
                print(f"Retry successful with valid ObjectId (_id: {result.inserted_id})")
            except Exception as retry_e:
                print(f"Retry failed: {retry_e}")
        else:
            print("   No valid instructor found")

    db.client.close()

def handle_missing_required_fields_error():
    """
    Task 6.2.3: Handle Missing Required Fields
    - Tries to insert user without 'email' (required)
    - Catches WriteError (validation failure)
    """
    db = connect_db()

    incomplete_user = {
        "userId": "U-MISSING",
        # Missing 'email' (required)
        "firstName": "Missing",
        "lastName": "Field",
        "role": "student",
        "dateJoined": utcnow(),
        "profile": {"bio": "Incomplete bio"},
        "isActive": True
    }

    try:
        db.users.insert_one(incomplete_user)
        print("Insert successful (unexpected - no required field error?)")
    except errors.WriteError as e:
        print(f"WriteError (Missing Required) caught: {e}")
        print("   Handling: Add missing field...")
        # Handle: Add required 'email'
        incomplete_user["email"] = "missing.field@eduhub.local"
        try:
            result = db.users.insert_one(incomplete_user)
            print(f"Retry successful with added email (_id: {result.inserted_id})")
        except Exception as retry_e:
            print(f"Retry failed: {retry_e}")

    db.client.close()

def main():
    print("=== Task 6.2: Error Handling Demo ===\n")

    print("--- 1. Duplicate Key Error ---")
    handle_duplicate_key_error()

    print("\n--- 2. Invalid Data Type Error ---")
    handle_invalid_data_type_error()

    print("\n--- 3. Missing Required Fields Error ---")
    handle_missing_required_fields_error()

    print("\n=== All Errors Handled! Scripts catch and recover where possible. ===")

if __name__ == "__main__":
    main()